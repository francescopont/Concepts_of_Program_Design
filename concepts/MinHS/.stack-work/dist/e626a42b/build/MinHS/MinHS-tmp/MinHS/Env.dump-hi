
==================== FINAL INTERFACE ====================
2019-12-08 00:34:28.9677921 UTC

interface main:MinHS.Env 8065
  interface hash: d8ac5dc97b060c7135b04390f9cec634
  ABI hash: 5b766e206aad32c9f714b5cb90be0cfa
  export-list hash: db007a7dc8ec6efa23b3facdf53405a2
  orphan hash: 6b2e7faf96d25c1f054542fba1fc682c
  flag hash: 1faae5399a98a9881e19b2a0edc4746f
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  MinHS.Env.add
  MinHS.Env.addAll
  MinHS.Env.empty
  MinHS.Env.lookup
  MinHS.Env.Env{MinHS.Env.Env}
module dependencies:
package dependencies: array-0.5.3.0 base-4.12.0.0
                      containers-0.6.0.1 deepseq-1.4.4.0 ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Set.Internal
import  -/  base-4.12.0.0:Data.Foldable bdeac546b12282c8986759606b9295a5
import  -/  base-4.12.0.0:Data.Monoid 6c9a55f5db4d603c7dc886429cfdb869
import  -/  base-4.12.0.0:Data.Traversable a1295a294c330074a1316dd1dc97c6f8
import  -/  base-4.12.0.0:GHC.Base fbe365a916ebeeeb4bc1f895dbe83e42
import  -/  base-4.12.0.0:GHC.Num 8203d3fee487126cffd5e55ba5d0e8c3
import  -/  base-4.12.0.0:GHC.Real 3b42f3125c1d17d4e4b4437a3c97310f
import  -/  base-4.12.0.0:GHC.Show fa6032f3f820e8e8ec87b97bdca4e160
import  -/  base-4.12.0.0:Prelude 80c668cb99fbafebd524c5e897f8c982
import  -/  containers-0.6.0.1:Data.Map f8621a8036f72702e0808c37110a78b8
import  -/  containers-0.6.0.1:Data.Map.Internal 36e498cd2f4fdcf0c685d8fd1f035ed1
import  -/  ghc-prim-0.5.3:GHC.Classes 6002495dc43e58d28c87e5e5e058752a
c456e072d49a4cb967896b2b6c37de0b
  $fEqEnv :: GHC.Classes.Eq e => GHC.Classes.Eq (MinHS.Env.Env e)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: CONLIKE,
     Unfolding: DFun: @ e (v :: GHC.Classes.Eq e).
                  @ (MinHS.Env.Env e)
                  (MinHS.Env.$fEqEnv2 @ e v)
                    `cast`
                  (Sym (MinHS.Env.N:Env[0]) <e>_N
                   ->_R Sym (MinHS.Env.N:Env[0]) <e>_N
                   ->_R <GHC.Types.Bool>_R)
                  (MinHS.Env.$fEqEnv1 @ e v)
                    `cast`
                  (Sym (MinHS.Env.N:Env[0]) <e>_N
                   ->_R Sym (MinHS.Env.N:Env[0]) <e>_N
                   ->_R <GHC.Types.Bool>_R) -}
d41a195a0f871cdf0777e908119668e0
  $fEqEnv1 ::
    GHC.Classes.Eq e =>
    Data.Map.Internal.Map [GHC.Types.Char] e
    -> Data.Map.Internal.Map [GHC.Types.Char] e -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ e ($dEq :: GHC.Classes.Eq e) ->
                 Data.Map.Internal.$fEqMap_$c/=
                   @ [GHC.Types.Char]
                   @ e
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   $dEq) -}
7e727f678b23f057f3e74f712d76fcfd
  $fEqEnv2 ::
    GHC.Classes.Eq e =>
    Data.Map.Internal.Map [GHC.Types.Char] e
    -> Data.Map.Internal.Map [GHC.Types.Char] e -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ e ($dEq :: GHC.Classes.Eq e) ->
                 Data.Map.Internal.$fEqMap_$c==
                   @ [GHC.Types.Char]
                   @ e
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   $dEq) -}
c456e072d49a4cb967896b2b6c37de0b
  $fFoldableEnv :: Data.Foldable.Foldable MinHS.Env.Env
  DFunId
  {- Inline: CONLIKE,
     Unfolding: DFun:.
                  @ MinHS.Env.Env
                  (Data.Map.Internal.$fFoldableMap_$cfold @ [GHC.Types.Char])
                    `cast`
                  (forall (m :: <*>_N).
                   <GHC.Base.Monoid m>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <m>_N
                   ->_R <m>_R)
                  (Data.Map.Internal.$fFoldableMap_$cfoldMap @ [GHC.Types.Char])
                    `cast`
                  (forall (m :: <*>_N) (a :: <*>_N).
                   <GHC.Base.Monoid m>_R
                   ->_R <a -> m>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N
                   ->_R <m>_R)
                  (\ @ a @ b -> Data.Map.Internal.foldr @ a @ b @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b -> b>_R
                   ->_R <b>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N
                   ->_R <b>_R)
                  (\ @ a @ b -> Data.Map.Internal.foldr' @ a @ b @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b -> b>_R
                   ->_R <b>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N
                   ->_R <b>_R)
                  (\ @ b @ a -> Data.Map.Internal.foldl @ b @ a @ [GHC.Types.Char])
                    `cast`
                  (forall (b :: <*>_N) (a :: <*>_N).
                   <b -> a -> b>_R
                   ->_R <b>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N
                   ->_R <b>_R)
                  (\ @ b @ a -> Data.Map.Internal.foldl' @ b @ a @ [GHC.Types.Char])
                    `cast`
                  (forall (b :: <*>_N) (a :: <*>_N).
                   <b -> a -> b>_R
                   ->_R <b>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N
                   ->_R <b>_R)
                  (Data.Map.Internal.$fFoldableMap_$cfoldr1 @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N).
                   <a -> a -> a>_R ->_R Sym (MinHS.Env.N:Env[0]) <a>_N ->_R <a>_R)
                  (Data.Map.Internal.$fFoldableMap_$cfoldl1 @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N).
                   <a -> a -> a>_R ->_R Sym (MinHS.Env.N:Env[0]) <a>_N ->_R <a>_R)
                  (Data.Map.Internal.elems @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N). Sym (MinHS.Env.N:Env[0]) <a>_N ->_R <[a]>_R)
                  (Data.Map.Internal.null @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (MinHS.Env.N:Env[0]) <a>_N ->_R <GHC.Types.Bool>_R)
                  (Data.Map.Internal.size @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N).
                   Sym (MinHS.Env.N:Env[0]) <a>_N ->_R <GHC.Types.Int>_R)
                  (Data.Map.Internal.$fFoldableMap_$celem @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Classes.Eq a>_R
                   ->_R <a>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N
                   ->_R <GHC.Types.Bool>_R)
                  (Data.Map.Internal.$fFoldableMap_$cmaximum @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Classes.Ord a>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N
                   ->_R <a>_R)
                  (Data.Map.Internal.$fFoldableMap_$cminimum @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Classes.Ord a>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N
                   ->_R <a>_R)
                  (Data.Map.Internal.$fFoldableMap_$csum @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Num.Num a>_R ->_R Sym (MinHS.Env.N:Env[0]) <a>_N ->_R <a>_R)
                  (Data.Map.Internal.$fFoldableMap_$cproduct @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N).
                   <GHC.Num.Num a>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N
                   ->_R <a>_R) -}
c456e072d49a4cb967896b2b6c37de0b
  $fFunctorEnv :: GHC.Base.Functor MinHS.Env.Env
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ MinHS.Env.Env
                  (Data.Map.Internal.$fFunctorMap_$cfmap @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a -> b>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N
                   ->_R Sym (MinHS.Env.N:Env[0]) <b>_N)
                  (Data.Map.Internal.$fFunctorMap_$c<$ @ [GHC.Types.Char])
                    `cast`
                  (forall (a :: <*>_N) (b :: <*>_N).
                   <a>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <b>_N
                   ->_R Sym (MinHS.Env.N:Env[0]) <a>_N) -}
c456e072d49a4cb967896b2b6c37de0b
  $fMonoidEnv :: GHC.Base.Monoid (MinHS.Env.Env e)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (MinHS.Env.Env e)
                  (MinHS.Env.$fSemigroupEnv @ e)
                  (Data.Map.Internal.Tip @ [GHC.Types.Char] @ e)
                    `cast`
                  (Sym (MinHS.Env.N:Env[0]) <e>_N)
                  (MinHS.Env.$fMonoidEnv_$sunion @ e)
                    `cast`
                  (Sym (MinHS.Env.N:Env[0]) <e>_N
                   ->_R Sym (MinHS.Env.N:Env[0]) <e>_N
                   ->_R Sym (MinHS.Env.N:Env[0]) <e>_N)
                  (MinHS.Env.$fMonoidEnv1 @ e)
                    `cast`
                  (([Sym (MinHS.Env.N:Env[0]) <e>_N])_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <e>_N) -}
1f1795b85adf33d67be6c9f610a6c931
  $fMonoidEnv1 ::
    [Data.Map.Internal.Map [GHC.Types.Char] e]
    -> Data.Map.Internal.Map [GHC.Types.Char] e
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ e (ts :: [Data.Map.Internal.Map [GHC.Types.Char] e]) ->
                 MinHS.Env.$fMonoidEnv2
                   @ e
                   ts
                   (Data.Map.Internal.Tip @ [GHC.Types.Char] @ e)) -}
cce2e6f929e4306f1580efbaf5575805
  $fMonoidEnv2 ::
    [Data.Map.Internal.Map [GHC.Types.Char] e]
    -> Data.Map.Internal.Map [GHC.Types.Char] e
    -> Data.Map.Internal.Map [GHC.Types.Char] e
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
437d5b03a000452094fabb6e325a570b
  $fMonoidEnv_$sunion ::
    Data.Map.Internal.Map [GHC.Types.Char] a
    -> Data.Map.Internal.Map [GHC.Types.Char] a
    -> Data.Map.Internal.Map [GHC.Types.Char] a
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [~] -}
c456e072d49a4cb967896b2b6c37de0b
  $fSemigroupEnv :: GHC.Base.Semigroup (MinHS.Env.Env e)
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun: @ e.
                  @ (MinHS.Env.Env e)
                  (MinHS.Env.$fMonoidEnv_$sunion @ e)
                    `cast`
                  (Sym (MinHS.Env.N:Env[0]) <e>_N
                   ->_R Sym (MinHS.Env.N:Env[0]) <e>_N
                   ->_R Sym (MinHS.Env.N:Env[0]) <e>_N)
                  (MinHS.Env.$fSemigroupEnv2 @ e)
                    `cast`
                  ((GHC.Base.NonEmpty (Sym (MinHS.Env.N:Env[0]) <e>_N))_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <e>_N)
                  (MinHS.Env.$fSemigroupEnv1 @ e)
                    `cast`
                  (forall (b :: <*>_N).
                   <GHC.Real.Integral b>_R
                   ->_R <b>_R
                   ->_R Sym (MinHS.Env.N:Env[0]) <e>_N
                   ->_R Sym (MinHS.Env.N:Env[0]) <e>_N) -}
bfb01fe101c8f2fa4b284fe6840771fb
  $fSemigroupEnv1 ::
    GHC.Real.Integral b =>
    b
    -> Data.Map.Internal.Map [GHC.Types.Char] e
    -> Data.Map.Internal.Map [GHC.Types.Char] e
  {- Arity: 3,
     Strictness: <S(S(LS(LC(C(S))LLLLLL)L)LLLLLLLL),1*U(1*U(1*U(A,A,A,A,A,A,1*C1(U)),1*U(A,1*C1(C1(U)),A,A,A,A,A,A),A),A,A,A,A,A,A,A,A)><L,U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ e
                   @ b
                   ($dIntegral :: GHC.Real.Integral b)
                   (w2 :: b)
                   (w3 :: Data.Map.Internal.Map [GHC.Types.Char] e) ->
                 case $dIntegral of ww { GHC.Real.C:Integral ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ->
                 case ww1 of ww10 { GHC.Real.C:Real ww11 ww12 ww13 ->
                 case ww12 of ww14 { GHC.Classes.C:Ord ww15 ww16 ww17 ww18 ww19 ww20 ww21 ww22 ->
                 Data.Map.Internal.$w$cstimes
                   @ [GHC.Types.Char]
                   @ e
                   @ b
                   ww11
                   ww16
                   w2
                   w3 } } }) -}
74388c6960da1286a14272dd2be53219
  $fSemigroupEnv2 ::
    GHC.Base.NonEmpty (Data.Map.Internal.Map [GHC.Types.Char] e)
    -> Data.Map.Internal.Map [GHC.Types.Char] e
  {- Arity: 1, Strictness: <S(SS),1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ e
                   (w1 :: GHC.Base.NonEmpty
                            (Data.Map.Internal.Map [GHC.Types.Char] e)) ->
                 case w1 of ww { GHC.Base.:| ww1 ww2 ->
                 Data.Map.Internal.$w$csconcat
                   @ [GHC.Types.Char]
                   @ e
                   GHC.Classes.$fOrd[]_$s$fOrd[]1
                   ww1
                   ww2 }) -}
c456e072d49a4cb967896b2b6c37de0b
  $fShowEnv :: GHC.Show.Show e => GHC.Show.Show (MinHS.Env.Env e)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(C1(U))),A,A)>m, Inline: CONLIKE,
     Unfolding: DFun: @ e (v :: GHC.Show.Show e).
                  @ (MinHS.Env.Env e)
                  (MinHS.Env.$fShowEnv_$cshowsPrec @ e v)
                  (MinHS.Env.$fShowEnv_$cshow @ e v)
                  (MinHS.Env.$fShowEnv_$cshowList @ e v) -}
c868dffa86affbe798a65118915f2dee
  $fShowEnv1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
d7e7e80f3f26a6e0ad04059e75904ceb
  $fShowEnv2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# MinHS.Env.$fShowEnv3) -}
9144dd72e4474e6dcb1e5407e4db06da
  $fShowEnv3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Env "#) -}
c456e072d49a4cb967896b2b6c37de0b
  $fShowEnv_$cshow ::
    GHC.Show.Show e => MinHS.Env.Env e -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(C1(U))),A,A)><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ e ($dShow :: GHC.Show.Show e) (x :: MinHS.Env.Env e) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n MinHS.Env.$fShowEnv2)
                   (Data.Map.Internal.$w$cshowsPrec
                      @ [GHC.Types.Char]
                      @ e
                      GHC.Show.$fShow[]_$s$fShow[]1
                      $dShow
                      11#
                      x `cast` (MinHS.Env.N:Env[0] <e>_N)
                      (GHC.Types.[] @ GHC.Types.Char))) -}
c456e072d49a4cb967896b2b6c37de0b
  $fShowEnv_$cshowList ::
    GHC.Show.Show e => [MinHS.Env.Env e] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C1(U))),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ e
                   ($dShow :: GHC.Show.Show e)
                   (ls :: [MinHS.Env.Env e])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (MinHS.Env.Env e)
                   (MinHS.Env.$fShowEnv_$cshowsPrec @ e $dShow MinHS.Env.$fShowEnv1)
                   ls
                   s) -}
c456e072d49a4cb967896b2b6c37de0b
  $fShowEnv_$cshowsPrec ::
    GHC.Show.Show e =>
    GHC.Types.Int -> MinHS.Env.Env e -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,U(C(C1(C1(U))),A,A)><S(S),1*U(U)><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ e
                   (w :: GHC.Show.Show e)
                   (w1 :: GHC.Types.Int)
                   (w2 :: MinHS.Env.Env e) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 MinHS.Env.$w$cshowsPrec @ e w ww1 w2 }) -}
c456e072d49a4cb967896b2b6c37de0b
  $fTraversableEnv :: Data.Traversable.Traversable MinHS.Env.Env
  DFunId
  {- Strictness: m, Inline: CONLIKE,
     Unfolding: DFun:.
                  @ MinHS.Env.Env
                  MinHS.Env.$fFunctorEnv
                  MinHS.Env.$fFoldableEnv
                  MinHS.Env.$fTraversableEnv_$ctraverse
                  MinHS.Env.$fTraversableEnv_$csequenceA
                  MinHS.Env.$fTraversableEnv_$cmapM
                  MinHS.Env.$fTraversableEnv_$csequence -}
83364d0df72188e6a89483d8b4cf8dd7
  $fTraversableEnv1 ::
    Data.Map.Internal.Map GHC.Base.String b
    -> Data.Map.Internal.Map GHC.Base.String b
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ b (b1 :: Data.Map.Internal.Map GHC.Base.String b) -> b1) -}
c456e072d49a4cb967896b2b6c37de0b
  $fTraversableEnv_$cmapM ::
    GHC.Base.Monad m =>
    (a -> m b) -> MinHS.Env.Env a -> m (MinHS.Env.Env b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(C(C1(U)),A),1*C1(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,C(U)><L,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ m :: * -> * @ a @ b ($dMonad :: GHC.Base.Monad m) ->
                 MinHS.Env.$fTraversableEnv_$ctraverse
                   @ m
                   @ a
                   @ b
                   (GHC.Base.$p1Monad @ m $dMonad)) -}
c456e072d49a4cb967896b2b6c37de0b
  $fTraversableEnv_$csequence ::
    GHC.Base.Monad m => MinHS.Env.Env (m a) -> m (MinHS.Env.Env a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(C(C(S))L)LLLLL)LLLL),1*U(1*U(1*U(C(C1(U)),A),1*C1(U),C(C1(U)),C(C1(C1(U))),A,A),A,A,A,A)><L,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ m :: * -> * @ a ($dMonad :: GHC.Base.Monad m) ->
                 MinHS.Env.$fTraversableEnv_$ctraverse
                   @ m
                   @ (m a)
                   @ a
                   (GHC.Base.$p1Monad @ m $dMonad)
                   (GHC.Base.id @ (m a))) -}
c456e072d49a4cb967896b2b6c37de0b
  $fTraversableEnv_$csequenceA ::
    GHC.Base.Applicative f =>
    MinHS.Env.Env (f a) -> f (MinHS.Env.Env a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLL),1*U(1*U(C(C1(U)),A),1*C1(U),C(C1(U)),C(C1(C1(U))),A,A)><L,1*U>,
     Inline: (sat-args=0),
     Unfolding: InlineRule (0, False, False)
                (\ @ f :: * -> * @ a ($dApplicative :: GHC.Base.Applicative f) ->
                 MinHS.Env.$fTraversableEnv_$ctraverse
                   @ f
                   @ (f a)
                   @ a
                   $dApplicative
                   (GHC.Base.id @ (f a))) -}
c456e072d49a4cb967896b2b6c37de0b
  $fTraversableEnv_$ctraverse ::
    GHC.Base.Applicative f =>
    (a -> f b) -> MinHS.Env.Env a -> f (MinHS.Env.Env b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(S(C(C(S))L)LLLLL),1*U(1*U(C(C1(U)),A),1*C1(U),C(C1(U)),C(C1(C1(U))),A,A)><L,C(U)><L,1*U>,
     Inline: [2],
     Unfolding: InlineRule (3, True, False)
                (\ @ f :: * -> *
                   @ a
                   @ b
                   (w :: GHC.Base.Applicative f)
                   (w1 :: a -> f b)
                   (w2 :: MinHS.Env.Env a) ->
                 case w of ww { GHC.Base.C:Applicative ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case ww1 of ww7 { GHC.Base.C:Functor ww8 ww9 ->
                 MinHS.Env.$w$ctraverse @ f @ a @ b ww8 ww2 ww3 ww4 w1 w2 } }) -}
6aa295d880d8bb66940cd59c19d97693
  $sinsertR_$sgo13 ::
    [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> a1
    -> Data.Map.Internal.Map [GHC.Types.Char] a1
    -> Data.Map.Internal.Map [GHC.Types.Char] a1
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,1*U> -}
c91cd408f30d0a452762c172fbc3f182
  $sinsert_$sgo13 ::
    GHC.Base.String
    -> GHC.Base.String
    -> a1
    -> Data.Map.Internal.Map GHC.Base.String a1
    -> Data.Map.Internal.Map GHC.Base.String a1
  {- Arity: 4, Strictness: <L,U><S,1*U><L,U><S,1*U> -}
446fb94d09cdd6beeaa45cf0ae5ad65d
  $slookup1 ::
    GHC.Base.String
    -> Data.Map.Internal.Map GHC.Base.String a -> GHC.Maybe.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
ac63dfad466a483e7741ab235d3d6a80
  $tc'Env :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3052209817904533611##
                   439040089541534767##
                   MinHS.Env.$trModule
                   MinHS.Env.$tc'Env2
                   1#
                   MinHS.Env.$tc'Env1) -}
5b19c8f6e27c109ddc50f0433cb9b346
  $tc'Env1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
beb1a69d31f5e45a07950e5b9c7f19ae
  $tc'Env2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MinHS.Env.$tc'Env3) -}
70376e62cd3e9c3556de31388774642f
  $tc'Env3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'Env"#) -}
721eac0307a8759962d5964eae398f61
  $tcEnv :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17879386950459573297##
                   16266089384529010719##
                   MinHS.Env.$trModule
                   MinHS.Env.$tcEnv1
                   0#
                   GHC.Types.krep$*Arr*) -}
7096bafcb739160c5fd356cde54a91f8
  $tcEnv1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MinHS.Env.$tcEnv2) -}
9ea3febca59324b7d9dc18aabdeeed03
  $tcEnv2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Env"#) -}
7c47a4ecea15e082926d15cae50f8301
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   MinHS.Env.$trModule3
                   MinHS.Env.$trModule1) -}
fa364e0d7637ede3741b8d1de0786a71
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MinHS.Env.$trModule2) -}
ffc48b5363242fff06f3f5b4cf39733a
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("MinHS.Env"#) -}
ac4edbe5a77ebccc96bf38e869fe2674
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS MinHS.Env.$trModule4) -}
96efdbc3200e255fe0cb0174e50976f2
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
c456e072d49a4cb967896b2b6c37de0b
  $w$cshowsPrec ::
    GHC.Show.Show e =>
    GHC.Prim.Int# -> MinHS.Env.Env e -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(C1(U))),A,A)><S,U><L,1*U>,
     Inline: [2],
     Unfolding: (\ @ e
                   (w :: GHC.Show.Show e)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: MinHS.Env.Env e) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Data.Map.Internal.$w$cshowsPrec
                       @ [GHC.Types.Char]
                       @ e
                       GHC.Show.$fShow[]_$s$fShow[]1
                       w
                       11#
                       w1 `cast` (MinHS.Env.N:Env[0] <e>_N)
                 } in
                 case GHC.Prim.>=# ww 11# of lwild {
                   DEFAULT
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char MinHS.Env.$fShowEnv2 (g x)
                   1#
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.$fShow(,)4
                        (GHC.Base.++
                           @ GHC.Types.Char
                           MinHS.Env.$fShowEnv2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.$fShow(,)2 x))) }) -}
c456e072d49a4cb967896b2b6c37de0b
  $w$ctraverse ::
    (forall a1 b1. (a1 -> b1) -> f a1 -> f b1)
    -> (forall a1. a1 -> f a1)
    -> (forall a1 b1. f (a1 -> b1) -> f a1 -> f b1)
    -> (forall a1 b1 c. (a1 -> b1 -> c) -> f a1 -> f b1 -> f c)
    -> (a -> f b)
    -> MinHS.Env.Env a
    -> f (MinHS.Env.Env b)
  {- Arity: 6, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,1*C1(U)><L,C(C1(U))><L,C(C1(C1(U)))><L,C(U)><L,1*U>,
     Inline: [2],
     Unfolding: (\ @ f :: * -> *
                   @ a
                   @ b
                   (ww :: forall a1 b1. (a1 -> b1) -> f a1 -> f b1)
                   (ww1 :: forall a1. a1 -> f a1)
                   (ww2 :: forall a1 b1. f (a1 -> b1) -> f a1 -> f b1)
                   (ww3 :: forall a1 b1 c. (a1 -> b1 -> c) -> f a1 -> f b1 -> f c)
                   (w :: a -> f b)
                   (w1 :: MinHS.Env.Env a) ->
                 ww
                   @ (Data.Map.Internal.Map GHC.Base.String b)
                   @ (MinHS.Env.Env b)
                   (MinHS.Env.$fTraversableEnv1 @ b)
                     `cast`
                   (<Data.Map.Internal.Map GHC.Base.String b>_R
                    ->_R Sym (MinHS.Env.N:Env[0]) <b>_N)
                   (let {
                      lvl :: f (Data.Map.Internal.Map [GHC.Types.Char] b)
                      = ww1
                          @ (Data.Map.Internal.Map [GHC.Types.Char] b)
                          (Data.Map.Internal.Tip @ [GHC.Types.Char] @ b)
                    } in
                    letrec {
                      go13 :: Data.Map.Internal.Map [GHC.Types.Char] a
                              -> f (Data.Map.Internal.Map [GHC.Types.Char] b)
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: Data.Map.Internal.Map [GHC.Types.Char] a) ->
                        case ds of wild {
                          Data.Map.Internal.Bin dt k1 v ds1 ds2
                          -> case dt of ds3 {
                               DEFAULT
                               -> ww2
                                    @ (Data.Map.Internal.Map [GHC.Types.Char] b)
                                    @ (Data.Map.Internal.Map [GHC.Types.Char] b)
                                    (ww3
                                       @ (Data.Map.Internal.Map [GHC.Types.Char] b)
                                       @ b
                                       @ (Data.Map.Internal.Map [GHC.Types.Char] b
                                          -> Data.Map.Internal.Map [GHC.Types.Char] b)
                                       (\ (x :: Data.Map.Internal.Map [GHC.Types.Char] b)
                                          (y :: b)
                                          (eta :: Data.Map.Internal.Map [GHC.Types.Char] b) ->
                                        case x of dt1 { DEFAULT ->
                                        case eta of dt2 { DEFAULT ->
                                        Data.Map.Internal.Bin
                                          @ [GHC.Types.Char]
                                          @ b
                                          ds3
                                          k1
                                          y
                                          dt1
                                          dt2 } })
                                       (go13 ds1)
                                       (w v))
                                    (go13 ds2)
                               1#
                               -> ww
                                    @ b
                                    @ (Data.Map.Internal.Map [GHC.Types.Char] b)
                                    (\ (v' :: b) ->
                                     Data.Map.Internal.Bin
                                       @ [GHC.Types.Char]
                                       @ b
                                       1#
                                       k1
                                       v'
                                       (Data.Map.Internal.Tip @ [GHC.Types.Char] @ b)
                                       (Data.Map.Internal.Tip @ [GHC.Types.Char] @ b))
                                    (w v) }
                          Data.Map.Internal.Tip -> lvl }
                    } in
                    go13 w1 `cast` (MinHS.Env.N:Env[0] <a>_N))) -}
3c21f03cbeef37e554db5fd81e449bc9
  $wpoly_go13 ::
    [GHC.Types.Char]
    -> Data.Map.Internal.Map [GHC.Types.Char] a
    -> (# Data.Map.Internal.Map [GHC.Types.Char] a,
          Data.Map.Internal.Map [GHC.Types.Char] a #)
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [2] -}
c456e072d49a4cb967896b2b6c37de0b
  newtype Env e = Env (Data.Map.Internal.Map GHC.Base.String e)
a9fdb69ff3f5145c4e7b190f52882a5b
  add :: MinHS.Env.Env e -> (GHC.Base.String, e) -> MinHS.Env.Env e
  {- Arity: 2, Strictness: <S,1*U><S(SL),1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ e (ds :: MinHS.Env.Env e) (ds1 :: (GHC.Base.String, e)) ->
                 case ds1 of wild { (,) key elt ->
                 (MinHS.Env.$sinsert_$sgo13
                    @ e
                    key
                    key
                    elt
                    ds `cast` (MinHS.Env.N:Env[0] <e>_N))
                   `cast`
                 (Sym (MinHS.Env.N:Env[0]) <e>_N) }) -}
76619b069f6a63681148fc87b50676cd
  addAll ::
    MinHS.Env.Env e -> [(GHC.Base.String, e)] -> MinHS.Env.Env e
  {- Arity: 2, Strictness: <S,U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                MinHS.Env.addAll1
                  `cast`
                (forall (e :: <*>_N).
                 <MinHS.Env.Env e>_R
                 ->_R <[(GHC.Base.String, e)]>_R
                 ->_R Sym (MinHS.Env.N:Env[0]) <e>_N) -}
1f2db05d2a73412197feefdfee8cab89
  addAll1 ::
    MinHS.Env.Env e
    -> [(GHC.Base.String, e)]
    -> Data.Map.Internal.Map GHC.Base.String e
  {- Arity: 2, Strictness: <S,U><S,1*U>,
     Unfolding: (\ @ e
                   (ds :: MinHS.Env.Env e)
                   (pairs :: [(GHC.Base.String, e)]) ->
                 letrec {
                   go :: [(GHC.Base.String, e)]
                         -> Data.Map.Internal.Map GHC.Base.String e
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds1 :: [(GHC.Base.String, e)]) ->
                     case ds1 of wild {
                       [] -> ds `cast` (MinHS.Env.N:Env[0] <e>_N)
                       : y ys
                       -> case y of wild1 { (,) k e1 ->
                          MinHS.Env.$sinsert_$sgo13 @ e k k e1 (go ys) } }
                 } in
                 go pairs) -}
cb4af07b989f10cfdaf3f345e7a47581
  empty :: MinHS.Env.Env e
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True)
                (Data.Map.Internal.Tip @ GHC.Base.String)
                  `cast`
                (forall (e :: <*>_N). Sym (MinHS.Env.N:Env[0]) <e>_N) -}
fcfffb3a33229c66d11c03f41547678b
  lookup :: MinHS.Env.Env e -> GHC.Base.String -> GHC.Maybe.Maybe e
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ e (ds :: MinHS.Env.Env e) (var :: GHC.Base.String) ->
                 MinHS.Env.$slookup1
                   @ e
                   var
                   ds `cast` (MinHS.Env.N:Env[0] <e>_N)) -}
instance GHC.Classes.Eq [MinHS.Env.Env] = MinHS.Env.$fEqEnv
instance Data.Foldable.Foldable [MinHS.Env.Env]
  = MinHS.Env.$fFoldableEnv
instance GHC.Base.Functor [MinHS.Env.Env] = MinHS.Env.$fFunctorEnv
instance GHC.Base.Monoid [MinHS.Env.Env] = MinHS.Env.$fMonoidEnv
instance GHC.Base.Semigroup [MinHS.Env.Env]
  = MinHS.Env.$fSemigroupEnv
instance GHC.Show.Show [MinHS.Env.Env] = MinHS.Env.$fShowEnv
instance Data.Traversable.Traversable [MinHS.Env.Env]
  = MinHS.Env.$fTraversableEnv
"SPEC/MinHS.Env union @ [Char] _" [orphan] forall @ a
                                                  ($dOrd :: GHC.Classes.Ord [GHC.Types.Char])
  Data.Map.Internal.union @ [GHC.Types.Char] @ a $dOrd
  = MinHS.Env.$fMonoidEnv_$sunion @ a
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

